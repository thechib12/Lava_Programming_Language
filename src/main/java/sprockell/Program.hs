module Program where

import BasicFunctions
import HardwareTypes
import Sprockell
import System
import Simulation

prog0 :: [Instruction]
prog0 = [
          Load (ImmValue 0) regA, 
          Store regA (DirAddr 1), 
          Load (ImmValue 0) regB, 
          WriteInstr regB (DirAddr 14), 
          Load (ImmValue 7) regC, 
          Push regC, 
          Load (ImmValue 2) regD, 
          Push regD, 
          Push reg0, 
          Load (ImmValue 12) regE, 
          Push regE, 
          Jump (Abs 81), 
          Pop reg0, 
          Pop regE, 
          Pop reg0, 
          Pop reg0, 
          Store regE (DirAddr 3), 
          Load (DirAddr 3) regF, 
          Store regF (DirAddr 1), 
          Load (ImmValue 1) regG, 
          WriteInstr reg0 (DirAddr 1), 
          WriteInstr regG (DirAddr 2), 
          Load (ImmValue 1) regH, 
          WriteInstr reg0 (DirAddr 3), 
          WriteInstr regH (DirAddr 4), 
          Load (ImmValue 1) regI, 
          WriteInstr reg0 (DirAddr 5), 
          WriteInstr regI (DirAddr 6), 
          Load (ImmValue 1) regJ, 
          Load (ImmValue 2) regK, 
          Compute Mul regK regJ regK, 
          TestAndSet (IndAddr regK), 
          Receive regL, 
          Branch regL (Abs 28), 
          Load (ImmValue 2) regM, 
          Load (ImmValue 2) regN, 
          Compute Mul regN regM regN, 
          TestAndSet (IndAddr regN), 
          Receive regO, 
          Branch regO (Abs 34), 
          Load (ImmValue 3) regP, 
          Load (ImmValue 2) regQ, 
          Compute Mul regQ regP regQ, 
          TestAndSet (IndAddr regQ), 
          Receive regR, 
          Branch regR (Abs 40), 
          Load (DirAddr 1) regS, 
          ReadInstr  (DirAddr 14), 
          Receive regA1, 
          Compute Add regS regA1 regB1, 
          Store regB1 (DirAddr 1), 
          EndProg, 
          Pop regC1, 
          DecrSP, 
          Pop reg0, 
          Pop reg0, 
          Pop regD1, 
          DecrSP, 
          DecrSP, 
          DecrSP, 
          Store regD1 (DirAddr 3), 
          TestAndSet (DirAddr 12), 
          Receive regE1, 
          Branch regE1 (Abs 61), 
          Load (DirAddr 3) regF1, 
          Load (ImmValue 10) regG1, 
          Compute Lt regF1 regG1 regH1, 
          Branch regH1 (Abs 78), 
          ReadInstr  (DirAddr 14), 
          Receive regI1, 
          Load (ImmValue 1) regJ1, 
          Compute Add regI1 regJ1 regK1, 
          WriteInstr regK1 (DirAddr 14), 
          Load (DirAddr 3) regL1, 
          Load (ImmValue 1) regM1, 
          Compute Add regL1 regM1 regN1, 
          Store regN1 (DirAddr 3), 
          Jump (Abs 64), 
          Nop, 
          WriteInstr reg0 (DirAddr 12), 
          Jump (Ind regC1), 
          Pop regO1, 
          DecrSP, 
          Pop reg0, 
          Pop reg0, 
          Pop reg0, 
          Pop regP1, 
          DecrSP, 
          DecrSP, 
          DecrSP, 
          DecrSP, 
          Pop reg0, 
          Pop reg0, 
          Pop regQ1, 
          DecrSP, 
          DecrSP, 
          DecrSP, 
          Compute Mul regP1 regQ1 regR1, 
          Pop regS1, 
          Pop reg0, 
          Push regR1, 
          Push regS1, 
          Jump (Ind regS1), 
          Jump (Ind regO1) 
       ] 
prog1 :: [Instruction]
prog1 = [
          Load (ImmValue 1) regA, 
          WriteInstr regA (DirAddr 1), 
          TestAndSet (DirAddr 1), 
          Receive regB, 
          Branch regB (Abs 2), 
          Pop reg0, 
          Pop reg0, 
          Pop regC, 
          DecrSP, 
          DecrSP, 
          DecrSP, 
          Store regC (DirAddr 3), 
          TestAndSet (DirAddr 12), 
          Receive regD, 
          Branch regD (Abs 12), 
          Load (DirAddr 3) regE, 
          Load (ImmValue 10) regF, 
          Compute Lt regE regF regG, 
          Branch regG (Abs 29), 
          ReadInstr  (DirAddr 14), 
          Receive regH, 
          Load (ImmValue 1) regI, 
          Compute Add regH regI regJ, 
          WriteInstr regJ (DirAddr 14), 
          Load (DirAddr 3) regK, 
          Load (ImmValue 1) regL, 
          Compute Add regK regL regM, 
          Store regM (DirAddr 3), 
          Jump (Abs 15), 
          Nop, 
          WriteInstr reg0 (DirAddr 12), 
          WriteInstr reg0 (DirAddr 2), 
          EndProg, 
          Pop regN, 
          DecrSP, 
          Pop reg0, 
          Pop reg0, 
          Pop reg0, 
          Pop regO, 
          DecrSP, 
          DecrSP, 
          DecrSP, 
          DecrSP, 
          Pop reg0, 
          Pop reg0, 
          Pop regP, 
          DecrSP, 
          DecrSP, 
          DecrSP, 
          Compute Mul regO regP regQ, 
          Pop regR, 
          Pop reg0, 
          Push regQ, 
          Push regR, 
          Jump (Ind regR), 
          Jump (Ind regN) 
       ] 
prog2 :: [Instruction]
prog2 = [
          Load (ImmValue 1) regA, 
          WriteInstr regA (DirAddr 3), 
          TestAndSet (DirAddr 3), 
          Receive regB, 
          Branch regB (Abs 2), 
          Pop reg0, 
          Pop reg0, 
          Pop regC, 
          DecrSP, 
          DecrSP, 
          DecrSP, 
          Store regC (DirAddr 3), 
          TestAndSet (DirAddr 12), 
          Receive regD, 
          Branch regD (Abs 12), 
          Load (DirAddr 3) regE, 
          Load (ImmValue 10) regF, 
          Compute Lt regE regF regG, 
          Branch regG (Abs 29), 
          ReadInstr  (DirAddr 14), 
          Receive regH, 
          Load (ImmValue 1) regI, 
          Compute Add regH regI regJ, 
          WriteInstr regJ (DirAddr 14), 
          Load (DirAddr 3) regK, 
          Load (ImmValue 1) regL, 
          Compute Add regK regL regM, 
          Store regM (DirAddr 3), 
          Jump (Abs 15), 
          Nop, 
          WriteInstr reg0 (DirAddr 12), 
          WriteInstr reg0 (DirAddr 4), 
          EndProg, 
          Pop regN, 
          DecrSP, 
          Pop reg0, 
          Pop reg0, 
          Pop reg0, 
          Pop regO, 
          DecrSP, 
          DecrSP, 
          DecrSP, 
          DecrSP, 
          Pop reg0, 
          Pop reg0, 
          Pop regP, 
          DecrSP, 
          DecrSP, 
          DecrSP, 
          Compute Mul regO regP regQ, 
          Pop regR, 
          Pop reg0, 
          Push regQ, 
          Push regR, 
          Jump (Ind regR), 
          Jump (Ind regN) 
       ] 
prog3 :: [Instruction]
prog3 = [
          Load (ImmValue 1) regA, 
          WriteInstr regA (DirAddr 5), 
          TestAndSet (DirAddr 5), 
          Receive regB, 
          Branch regB (Abs 2), 
          Pop reg0, 
          Pop reg0, 
          Pop regC, 
          DecrSP, 
          DecrSP, 
          DecrSP, 
          Store regC (DirAddr 3), 
          TestAndSet (DirAddr 12), 
          Receive regD, 
          Branch regD (Abs 12), 
          Load (DirAddr 3) regE, 
          Load (ImmValue 10) regF, 
          Compute Lt regE regF regG, 
          Branch regG (Abs 29), 
          ReadInstr  (DirAddr 14), 
          Receive regH, 
          Load (ImmValue 1) regI, 
          Compute Add regH regI regJ, 
          WriteInstr regJ (DirAddr 14), 
          Load (DirAddr 3) regK, 
          Load (ImmValue 1) regL, 
          Compute Add regK regL regM, 
          Store regM (DirAddr 3), 
          Jump (Abs 15), 
          Nop, 
          WriteInstr reg0 (DirAddr 12), 
          WriteInstr reg0 (DirAddr 6), 
          EndProg, 
          Pop regN, 
          DecrSP, 
          Pop reg0, 
          Pop reg0, 
          Pop reg0, 
          Pop regO, 
          DecrSP, 
          DecrSP, 
          DecrSP, 
          DecrSP, 
          Pop reg0, 
          Pop reg0, 
          Pop regP, 
          DecrSP, 
          DecrSP, 
          DecrSP, 
          Compute Mul regO regP regQ, 
          Pop regR, 
          Pop reg0, 
          Push regQ, 
          Push regR, 
          Jump (Ind regR), 
          Jump (Ind regN) 
       ] 
demoTest = sysTest [prog0, prog1, prog2, prog3]